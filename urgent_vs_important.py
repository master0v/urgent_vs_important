#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 6.2
#  in conjunction with Tcl version 8.6
#    Aug 21, 2021 06:26:23 PM -05  platform: Darwin

import sys, time

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk


try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

#import tkinter.dnd as dnd
#import logging
#logger = logging.getLogger(__name__)
#logger.setLevel(logging.DEBUG)

import urgent_vs_important_support
from tasks_api import GoogleTasks

colors = ['blue',
  'orange',
  'green',
  'red',
  'purple',
  'brown',
  'pink',
  'gray',
  'olive',
  'cyan']

def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    top = Toplevel1 (root)
    urgent_vs_important_support.init(root, top)
    root.mainloop()


w = None
def create_Toplevel1(rt, *args, **kwargs):
  '''Starting point when module is imported by another module.
     Correct form of call: 'create_Toplevel1(root, *args, **kwargs)' .'''
  global w, w_win, root
  #rt = root
  root = rt
  w = tk.Toplevel (root)
  top = Toplevel1 (w)
  urgent_vs_important_support.init(w, top, *args, **kwargs)
  return (w, top)


def destroy_Toplevel1():
  global w
  w.destroy()
  w = None


class Toplevel1:

  def __init__(self, top=None):
    '''This class configures and populates the toplevel window.
       top is the toplevel containing window.'''
    _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
    _fgcolor = '#000000'  # X11 color: 'black'
    _compcolor = '#d9d9d9' # X11 color: 'gray85'
    _ana1color = '#d9d9d9' # X11 color: 'gray85'
    _ana2color = '#ececec' # Closest X11 color: 'gray92'
    self.style = ttk.Style()
    if sys.platform == "win32":
        self.style.theme_use('winnative')
    self.style.configure('.',background=_bgcolor)
    self.style.configure('.',foreground=_fgcolor)
    self.style.configure('.',font="TkDefaultFont")
    self.style.map('.',background=
        [('selected', _compcolor), ('active',_ana2color)])

    top.geometry("795x653+302+99")
    top.minsize(72, 15)
    top.maxsize(1399, 847)
    top.resizable(1,  1)
    top.title("Prioritize!")
    top.configure(background="#d9d9d9")
    top.configure(highlightbackground="#d9d9d9")
    top.configure(highlightcolor="black")
    

    self.style.configure('TSizegrip', background=_bgcolor)
    self.TSizegrip1 = ttk.Sizegrip(top)
    self.TSizegrip1.place(anchor='se', relx=1.0, rely=1.0)

    self.Canvas1 = tk.Canvas(top)
    self.Canvas1.place(relx=0.299, rely=0.006, relheight=0.983
            , relwidth=0.693)
    self.Canvas1.configure(background="#d9d9d9")
    self.Canvas1.configure(borderwidth="2")
    self.Canvas1.configure(highlightbackground="#d9d9d9")
    self.Canvas1.configure(highlightcolor="black")
    self.Canvas1.configure(insertbackground="black")
    self.Canvas1.configure(relief="ridge")
    self.Canvas1.configure(selectbackground="blue")
    self.Canvas1.configure(selectforeground="white")

    self.TSeparator1 = ttk.Separator(self.Canvas1)
    self.TSeparator1.place(relx=0.02, rely=0.514,  relwidth=0.958)

    self.TSeparator2 = ttk.Separator(self.Canvas1)
    self.TSeparator2.place(relx=0.508, rely=0.016,  relheight=0.981)
    self.TSeparator2.configure(orient="vertical")

    self.style.configure('Treeview',  font="TkDefaultFont")
    
    # Create a treeview
    self.Scrolledtreeview1 = ScrolledTreeView(top)    
    self.Scrolledtreeview1.place(relx=0.008, rely=0.006, relheight=0.98, relwidth=0.289)

    # build_treeview_support starting.
    self.Scrolledtreeview1.heading("#0",text="Unprioritized")
    self.Scrolledtreeview1.heading("#0",anchor="center")
    self.Scrolledtreeview1.column("#0",width="200")
    self.Scrolledtreeview1.column("#0",minwidth="120")
    self.Scrolledtreeview1.column("#0",stretch="1")
    self.Scrolledtreeview1.column("#0",anchor="w")
    
    print("loading tasks from your google account")
    self.gt = GoogleTasks()
    self.myTasks = self.gt.getTasks("Test") # pass a specific tasklist for testing

    color_index = 0
    list_index = 0
    parent_index = 0
    # adding parents
    for key in self.myTasks.keys():
      print (f"{key} has {len(self.myTasks[key])} tasks")
      self.Scrolledtreeview1.insert(
        '', tk.END, text=key, iid=list_index, open=True, tags=(colors[color_index], 'list_name') )
      parent_index = list_index
      list_index += 1
      # adding children sorted by key
      for position in sorted(self.myTasks[key].keys()):
        # get task coordinates
        coords = self.myTasks[key][position].get('coordinates')
        if not coords: # if the task has no position - add it to the tree
          self.Scrolledtreeview1.insert('', tk.END, text=self.myTasks[key][position]['title'],
            iid=list_index, open=False, tags=(colors[color_index], 'task') ) # , values=("Big2","Best")
          self.Scrolledtreeview1.move(list_index, parent_index, list_index)
          list_index += 1
        else: # otherwise add it to the canvas
          self.create_token(int(coords[0]), int(coords[1]),
            colors[color_index], self.myTasks[key][position]['title'])
    
      # color all the entries with tag
      self.Scrolledtreeview1.tag_configure(colors[color_index], foreground=colors[color_index])
      color_index += 1
      

    
    # this data is used to keep track of an
    # item being dragged
    self._drag_data = {"x": 0, "y": 0, "item": None}
    
    # add bindings for clicking, dragging and releasing over
    # any object with the "token" tag
    self.Canvas1.tag_bind("token", "<ButtonPress-1>", self.drag_start)
    self.Canvas1.tag_bind("token", "<ButtonRelease-1>", self.drag_stop)
    self.Canvas1.tag_bind("token", "<B1-Motion>", self.drag)
    
    # bind drag and drop events to the entire list
    # https://stackoverflow.com/questions/6740855/board-drawing-code-to-move-an-oval/6789351#6789351
    self.Scrolledtreeview1.bind("<ButtonPress-1>", self.tree_drag_start)
    self.Scrolledtreeview1.bind("<ButtonRelease-1>", self.tree_drag_stop)
    self.Scrolledtreeview1.bind("<B1-Motion>", self.tree_drag)
    
    
    
  def create_token(self, x, y, color, text):
      """Create a token at the given coordinate in the given color"""
      self.Canvas1.create_oval(
          x - 35,
          y - 15,
          x + 35,
          y + 15,
          outline=color,
          fill=color,
          tags=("token",),
      )
      self.Canvas1.create_text(x, y, text=text, tags=("token",))
      

  def drag_start(self, event):
    # record the item and its location
    self._drag_data["item"] = self.Canvas1.find_closest(event.x, event.y)[0]
    self._drag_data["x"] = event.x
    self._drag_data["y"] = event.y
    
    # change the cursor to hand
    self.Scrolledtreeview1.configure(cursor="hand")
    self.Canvas1.configure(cursor="hand")


  def drag_stop(self, event):
    print(f"stop: {self._drag_data['item']} x={event.x}, y={event.y}")
    
    # Update task with coordinates, and load them on start
    # based on that the GoogleTasks class will re-order them in the task list
    self.gt.updateTaskCoodinates("Test", self.myTasks["Test"][2], event.x, event.y)
    
    # reset the drag information
    self._drag_data["item"] = None
    self._drag_data["x"] = 0
    self._drag_data["y"] = 0
    
    
    #change the cursor back to arrow
    self.Scrolledtreeview1.configure(cursor="arrow")
    self.Canvas1.configure(cursor="arrow")


  def drag(self, event):
    # do not allow dragging outside of the canvas
    if event.x > self.Canvas1.winfo_width() or event.x < 0 or \
      event.y > self.Canvas1.winfo_height() or event.y < 0:
      return
    
    # compute how much the mouse has moved
    delta_x = event.x - self._drag_data["x"]
    delta_y = event.y - self._drag_data["y"]
    # move the object the appropriate amount
    self.move_token(self._drag_data["item"], delta_x, delta_y)
    # record the new position
    self._drag_data["x"] = event.x
    self._drag_data["y"] = event.y
   
    
  def move_token(self, token_item, delta_x, delta_y):
    if (token_item % 2) == 0:
      token_item -= 1
    #print(f"moving {token_item} and {token_item+1} by {delta_x}, {delta_y}")
    self.Canvas1.move(token_item, delta_x, delta_y)
    self.Canvas1.move(token_item+1, delta_x, delta_y)
    
    
  def tree_drag_start(self, event):
    # record the item and its location
    self._drag_data["x"] = event.x
    self._drag_data["y"] = event.y
    
    # change the cursor to hand
    self.Scrolledtreeview1.configure(cursor="hand")
    self.Canvas1.configure(cursor="hand")


  def tree_drag_stop(self, event):
    print(f"stop: {self._drag_data['item']} x={event.x}, y={event.y}")
    # recrord the new position in the task
    
    #TODO: Update task notes with coordinates, and load them on start
    
    
    # reset the drag information
    self._drag_data["item"] = None
    self._drag_data["x"] = 0
    self._drag_data["y"] = 0
    
    
    #change the cursor back to arrow
    self.Scrolledtreeview1.configure(cursor="arrow")
    self.Canvas1.configure(cursor="arrow")


  def tree_drag(self, event):
    
    tree_width = self.Scrolledtreeview1.winfo_width()
        
    # if we have dragged the item past the tree boundary, create new object 
    if event.x > tree_width and not self._drag_data["item"]:
      # get the text from the currently selected task
      selected_task = self.Scrolledtreeview1.item(self.Scrolledtreeview1.focus())
      # check to make sure it is a task, and not a 'list_name'
      if len(selected_task['tags']) > 1 and selected_task['tags'][1] == 'task':
        # and create a token with its name
        self.create_token(1, event.y, selected_task['tags'][0], selected_task['text'])
        self._drag_data["item"] = self.Canvas1.find_closest(0, event.y)[0] - 1
        # then remove the task from the list
        self.Scrolledtreeview1.delete(self.Scrolledtreeview1.selection()[0] )

     # Do not alow moving outside the canvas boundary
    if event.x > tree_width and self._drag_data["item"] and \
      event.x < self.Canvas1.winfo_width() + tree_width and \
      event.y < self.Canvas1.winfo_height() and event.y > 0 :   
      # compute how much the mouse has moved
      delta_x = event.x - self._drag_data["x"]
      delta_y = event.y - self._drag_data["y"]
      # move the token by that much
      self.move_token(self._drag_data["item"], delta_x, delta_y)
    
    # record the new mouse position
    self._drag_data["x"] = event.x
    self._drag_data["y"] = event.y
    
    

# The following code is added to facilitate the Scrolled widgets you specified.
class AutoScroll(object):
  '''Configure the scrollbars for a widget.'''
  def __init__(self, master):
    #  Rozen. Added the try-except clauses so that this class
    #  could be used for scrolled entry widget for which vertical
    #  scrolling is not supported. 5/7/14.
    try:
      vsb = ttk.Scrollbar(master, orient='vertical', command=self.yview)
    except:
      pass
    hsb = ttk.Scrollbar(master, orient='horizontal', command=self.xview)
    try:
      self.configure(yscrollcommand=self._autoscroll(vsb))
    except:
      pass
    self.configure(xscrollcommand=self._autoscroll(hsb))
    self.grid(column=0, row=0, sticky='nsew')
    try:
      vsb.grid(column=1, row=0, sticky='ns')
    except:
      pass
    hsb.grid(column=0, row=1, sticky='ew')
    master.grid_columnconfigure(0, weight=1)
    master.grid_rowconfigure(0, weight=1)
    # Copy geometry methods of master  (taken from ScrolledText.py)
    if py3:
      methods = tk.Pack.__dict__.keys() | tk.Grid.__dict__.keys() \
        | tk.Place.__dict__.keys()
    else:
      methods = tk.Pack.__dict__.keys() + tk.Grid.__dict__.keys() \
        + tk.Place.__dict__.keys()
    for meth in methods:
      if meth[0] != '_' and meth not in ('config', 'configure'):
        setattr(self, meth, getattr(master, meth))

  @staticmethod
  def _autoscroll(sbar):
    '''Hide and show scrollbar as needed.'''
    def wrapped(first, last):
      first, last = float(first), float(last)
      if first <= 0 and last >= 1:
        sbar.grid_remove()
      else:
        sbar.grid()
      sbar.set(first, last)
    return wrapped

  def __str__(self):
    return str(self.master)


def _create_container(func):
  '''Creates a ttk Frame with a given master, and use this new frame to
  place the scrollbars and the widget.'''
  def wrapped(cls, master, **kw):
    container = ttk.Frame(master)
    container.bind('<Enter>', lambda e: _bound_to_mousewheel(e, container))
    container.bind('<Leave>', lambda e: _unbound_to_mousewheel(e, container))
    return func(cls, container, **kw)
  return wrapped


class ScrolledTreeView(AutoScroll, ttk.Treeview):
  '''A standard ttk Treeview widget with scrollbars that will
  automatically show/hide as needed.'''
  @_create_container
  def __init__(self, master, **kw):
    ttk.Treeview.__init__(self, master, **kw)
    AutoScroll.__init__(self, master)


import platform
def _bound_to_mousewheel(event, widget):
    child = widget.winfo_children()[0]
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        child.bind_all('<MouseWheel>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-MouseWheel>', lambda e: _on_shiftmouse(e, child))
    else:
        child.bind_all('<Button-4>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Button-5>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-Button-4>', lambda e: _on_shiftmouse(e, child))
        child.bind_all('<Shift-Button-5>', lambda e: _on_shiftmouse(e, child))


def _unbound_to_mousewheel(event, widget):
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        widget.unbind_all('<MouseWheel>')
        widget.unbind_all('<Shift-MouseWheel>')
    else:
        widget.unbind_all('<Button-4>')
        widget.unbind_all('<Button-5>')
        widget.unbind_all('<Shift-Button-4>')
        widget.unbind_all('<Shift-Button-5>')


def _on_mousewheel(event, widget):
    if platform.system() == 'Windows':
        widget.yview_scroll(-1*int(event.delta/120),'units')
    elif platform.system() == 'Darwin':
        widget.yview_scroll(-1*int(event.delta),'units')
    else:
        if event.num == 4:
            widget.yview_scroll(-1, 'units')
        elif event.num == 5:
            widget.yview_scroll(1, 'units')


def _on_shiftmouse(event, widget):
    if platform.system() == 'Windows':
        widget.xview_scroll(-1*int(event.delta/120), 'units')
    elif platform.system() == 'Darwin':
        widget.xview_scroll(-1*int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.xview_scroll(-1, 'units')
        elif event.num == 5:
            widget.xview_scroll(1, 'units')

if __name__ == '__main__':
  vp_start_gui()





